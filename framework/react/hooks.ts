import { useContext, useMemo } from 'react'
import util from '../../shared/util.ts'
import type { RouterURL } from '../../types.ts'
import events from '../core/events.ts'
import { RouterContext } from './context.ts'

export class AsyncUseDenoError extends Error { }

/**
 * `useRouter` allows you to use `RouterURL` obeject of routing
 *
 * ```tsx
 * export default function App() {
 *   const { locale, pathname, routePath, params, query } = useRouter()
 *   return <p>{pathname}</p>
 * }
 * ```
 */
export function useRouter(): RouterURL {
  return useContext(RouterContext)
}

/**
 * `useDeno` allows you to use Deno runtime in build time(SSR).
 *
 * ```tsx
 * export default function App() {
 *   const version = useDeno(() => Deno.version.deno)
 *   return <p>{version}</p>
 * }
 * ```
 *
 * @param {Function} callback - hook callback.
 * @param {number} revalidate - revalidate duration in seconds.
 */
export function useDeno<T = any>(callback: () => (T | Promise<T>), revalidate?: number): T {
  const id = arguments[2] // generated by compiler
  const { pathname, query } = useRouter()
  return useMemo(() => {
    const global = globalThis as any
    const qs = query.toString()
    const dataUrl = 'pagedata://' + [pathname, qs].filter(Boolean).join('?')
    const expires = typeof revalidate === 'number' && !isNaN(revalidate) ? Date.now() + revalidate * 1000 : 0

    if (util.inDeno) {
      const renderingData = global['rendering-' + dataUrl]

      if (renderingData && id in renderingData) {
        return renderingData[id]  // 2+ pass
      }

      const v = callback()
      events.emit('useDeno-' + dataUrl, { id, value: v, expires })
      // thow an `AsyncUseDenoError` to break current rendering, then re-render
      if (v instanceof Promise) {
        throw new AsyncUseDenoError()
      }

      renderingData[id] = v
      return v
    }

    return global[dataUrl + '#' + id].value ?? null
  }, [id, pathname, query])
}
